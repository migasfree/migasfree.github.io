import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as s,o as i}from"./app-DaN48HUc.js";const n={};function r(t,e){return i(),o("div",null,[...e[0]||(e[0]=[s(`<h2 id="presentacion" tabindex="-1"><a class="header-anchor" href="#presentacion"><span>Presentación</span></a></h2><p>Charla preparada para la Conferencia Internacional de Software Libre, celebrada en enero de 2012 en Granada.</p><p>Soy Jose Antonio Chavarría y trabajo en el Servicio de Redes y Sistemas del Ayuntamiento de Zaragoza, desarrollando y manteniendo <code>AZLinux</code>, el escritorio libre que usamos, a día de hoy, unos 600 trabajadores municipales.</p><p>Vamos a ver el método que empleamos en <code>AZLinux</code> para personalizar nuestros escritorios.</p><h2 id="introduccion" tabindex="-1"><a class="header-anchor" href="#introduccion"><span>Introducción</span></a></h2><p>En primer lugar, vamos a repasar algunos conceptos básicos sobre la Gestión de la Configuración Software (en adelante GCS).</p><p>Esto permitirá establecer la base desde la que poder tratar las dificultades que vas a encontrarte a la hora de personalizar los escritorios GNU/Linux de tu organización, y de cómo puedes superarlas.</p><p>Finalmente veremos <code>migasfree</code>, la herramienta que ha sido clave en la evolución de <code>AZLinux</code>.</p><h2 id="la-permanencia-del-cambio" tabindex="-1"><a class="header-anchor" href="#la-permanencia-del-cambio"><span>La permanencia del cambio</span></a></h2><p>Un hombre no puede bañarse dos veces en el mismo río, porque el segundo día el río ya no es el mismo, y ni siquiera ese hombre es el mismo.</p><h2 id="el-cambio-es-deseable-e-inevitable" tabindex="-1"><a class="header-anchor" href="#el-cambio-es-deseable-e-inevitable"><span>El cambio es deseable e inevitable</span></a></h2><p>Dejando aparte la filosofía y centrándonos sólo en el mundo del software podemos decir que <strong>el cambio es inevitable y además es deseable</strong>.</p><p>Inevitable porque los desarrolladores no podemos evitar cometer errores y es mediante la modificación, o cambio en el software, que estos errores son corregidos. Son los llamados <strong>cambios correctivos</strong>.</p><p>Por otro lado el cambio es deseable ya que a menudo queremos incorporar nuevas funcionalidades al software o mejorar aquellas que ya existían. Mediante los <strong>cambios evolutivos</strong> es como mejoramos el software.</p><p>Estos cambios se producen desde que concebimos, construimos y también mientras mantenemos un proyecto software, es decir, durante todo su ciclo de vida.</p><h2 id="la-importancia-del-control" tabindex="-1"><a class="header-anchor" href="#la-importancia-del-control"><span>La importancia del control</span></a></h2><p>El gran reto de los proyectos software reside precisamente en gestionar, de forma controlada, dichos cambios usando alguna estrategia que favorezca y facilite el cambio.</p><p>De esto trata precisamente la <strong>GCS</strong>, un proceso de la Ingeniería del Software que identifica, hace seguimiento y controla cada uno de los cambios que se producen en los sistemas.</p><h2 id="conservacion-de-la-integridad" tabindex="-1"><a class="header-anchor" href="#conservacion-de-la-integridad"><span>Conservación de la integridad</span></a></h2><p>El objetivo de la Gestión de la Configuración es conservar la <strong>integridad</strong> de los sistemas frente a los cambios.</p><p>Un sistema será íntegro frente al cambio si:</p><ul><li>mantiene correctamente las <strong>relaciones</strong> entre los distintos cambios a medida que se van produciendo (el típico problema de dependencias entre elementos),</li><li>y además permite la <strong>auditoría</strong> de cambios (conocimiento del estado de un sistema al que se le han ido aplicando cambios sucesivamente).</li></ul><h2 id="proceso-gestion-de-configuracion-software" tabindex="-1"><a class="header-anchor" href="#proceso-gestion-de-configuracion-software"><span>Proceso Gestión de Configuración Software</span></a></h2><p>El proceso de la GCS es un conjunto de actividades que nos permitirá garantizar dicha integridad, y que podemos resumir en: <strong>petición</strong> de cambio, <strong>cambio</strong> y <strong>liberación</strong>.</p><p><strong>Petición de cambio</strong>: Cuando se nos reporta un error o una petición de mejora, lo primero que hacemos es identificar el elemento de configuración software (ECS) al que se refiere.</p><p>Un ECS es cualquier objeto software sometido a la GCS. Puede ser un manual de usuario, una especificación, un conjunto de datos para realizar pruebas, una aplicación, una librería, incluso las herramientas que se usan para realizar los cambios, etc.</p><p>Una vez identificado el ECS se registra la petición de cambio. Las herramientas típicas para registrar y hacer el seguimiento del cambio son los llamados gestores de proyectos (Redmine, Bugzilla, Tracker, etc.).</p><p>Cada <strong>petición de cambio</strong> es analizada más tarde pudiendo ser aceptada o rechazada. Si es rechazada se avisa al informador y se cierra la petición; si es aceptada se asigna la petición a alguien para que realice dicho cambio.</p><p>El <strong>cambio</strong> es la actividad que modifica el ECS, generando una nueva versión del ECS. En esta actividad se utilizan un conjunto muy diverso de herramientas, desde procesadores y editores de texto, sistemas de control de versiones, entornos de desarrollo integrados (IDE), depuradores, compiladores...</p><p>La <strong>liberación</strong> es la actividad de situar la nueva versión del ECS generada, en un repositorio o almacén para que posteriormente los clientes del ECS puedan acceder a él e instalarlo.</p><h2 id="gcs-en-proyectos-de-software-libre" tabindex="-1"><a class="header-anchor" href="#gcs-en-proyectos-de-software-libre"><span>GCS en proyectos de software libre</span></a></h2><p>Si observamos como en el mundo del software libre los distintos proyectos (Gnome, KDE, LibreOffice, Mozilla Firefox, Gimp, migasfree, etc.) realizan la <strong>GCS</strong>, vemos que realizan las actividades mencionadas liberando finalmente el código fuente del proyecto en internet, pero podemos observar cómo trabajan con distintos tipos de <strong>ECS</strong> (.png, .txt, .py, .c, .bin, etc.) usando los Sistemas de Control de Versiones que les proporcionan las denominadas forjas de proyectos (plataformas de desarrollo colaborativo como <a href="http://sourceforge.net" target="_blank" rel="noopener noreferrer">sourceforge.net</a>, <a href="http://github.com" target="_blank" rel="noopener noreferrer">github.com</a>, etc.).</p><p>Este código fuente será posteriormente compilado por los mantenedores de las Distribuciones GNU/Linux (Fedora, Red Hat, Debian, Ubuntu, etc.) realizando su propia GCS, pero a diferencia de los primeros, las Distribuciones GNU/Linux sólo trabajan sobre un único tipo de ECS: <strong>el paquete</strong>, donde introducirán el programa ya compilado.</p><p>Este simple hecho permite garantizar la integridad frente a los cambios de forma eficaz y sencilla como veremos a continuación.</p><h2 id="el-paquete-como-contenedor" tabindex="-1"><a class="header-anchor" href="#el-paquete-como-contenedor"><span>El paquete como contenedor</span></a></h2><p>Un <strong>paquete</strong> es un contenedor que encapsula un <strong>ECS</strong> liberado por un determinado proyecto, más su metainformación.</p><p>Contendrá, por tanto, el programa compilado para una determinada Distribución y arquitectura, más un conjunto amplio de información como puede ser: el autor del programa, la dirección del repositorio del proyecto, la versión del ECS, arquitectura, nombre del empaquetador, fecha de empaquetado, nombre del equipo en que se produjo el empaquetado, una descripción corta del contenido del paquete, una descripción larga, ...</p><p>Pero, además, suelen incluir:</p><ol><li><p><strong>Código</strong> a ejecutar antes y después de instalar, actualizar o eliminar el paquete.</p></li><li><p><strong>Dependencias</strong> con otros paquetes.</p></li></ol><p>Una vez que la Distribución GNU/Linux ha compilado y creado el paquete, lo <strong>libera</strong> poniéndolo en un <strong>repositorio</strong> público o almacén, a disposición de los clientes.</p><h2 id="actualizacion-de-software-en-linux" tabindex="-1"><a class="header-anchor" href="#actualizacion-de-software-en-linux"><span>Actualización de software en Linux</span></a></h2><p>¿Y cómo se actualizan los paquetes en los distintos escritorios GNU/Linux?</p><p>Los encargados de aplicar los cambios son los llamados <strong>gestores de paquetes</strong>. Un gestor de paquetes es un programa que compara los paquetes instalados con los paquetes de los repositorios configurados, detectando los que han sido modificados (han aumentado su versión), resolviendo sus dependencias y finalmente, si no hay conflictos, obtienen desde los repositorios sólo los paquetes necesarios. Ejemplos de gestores de paquetes son <code>yum</code>, <code>zypper</code> o <code>apt</code>.</p><p>Una vez han descargado los paquetes, dan órdenes a los <em>backends</em> (<code>rpm</code>, <code>dpkg</code>, etc.) para que se produzca la actualización. Los <em>backends</em> abren el paquete, y grosso modo:</p><ol><li><p>Extraen los ficheros del programa copiándolos en el sistema, y ejecutando además el código programado para antes y después de la actualización.</p></li><li><p>La metainformación es extraída del paquete y se almacena en la base de datos del backend.</p></li></ol><p>Decía Ian Murdock, fundador de Debian, que el gran aporte del software libre a la industria ha sido precisamente la invención del sistema de paquetería (paquete, repositorio, gestor de paquetes). Y no es para menos, ya que este sistema nos proporciona los dos requisitos necesarios que veíamos anteriormente y que garantizarán la integridad frente a los cambios, es decir:</p><ol><li><p>El control de <strong>dependencias</strong>, mediante el gestor de paquetes.</p></li><li><p>La <strong>auditoría</strong>, mediante las consultas a la base de datos a través del <em>backend</em>.</p></li></ol><p>Si estás acostumbrado a instalar programas mediante el típico <code>./configure</code>, <code>make</code>, <code>install</code>, tienes que hacerte consciente que estás rompiendo la integridad frente a los cambios cuando lo haces, ya que la base de datos del backend no es actualizada con este procedimiento (en la auditoría no saldrá reflejada este programa y además es posible que una actualización posterior del sistema podría hacer que tu programa dejase de funcionar). Tenlo en cuenta.</p><p>Recuerda esto: <strong>Todo lo que no sea instalar programas mediante el gestor de paquetes o el <em>backend</em>, rompe la integridad frente a los cambios de tu sistema</strong>.</p><h2 id="administrando-equipos" tabindex="-1"><a class="header-anchor" href="#administrando-equipos"><span>Administrando equipos</span></a></h2><p>Hasta ahora, hemos hablado de la <strong>GCS</strong> en general, y de cómo las Distribuciones GNU/linux en particular utilizan el sistema de paquetería para <strong>garantizar la integridad</strong> frente al cambio.</p><p>Esto está muy bien si tienes un equipo doméstico, ya que con el simple hecho de dar la orden al gestor de paquetes para que actualice tu sistema, todos los cambios producidos por los distintos proyectos que forman parte de tu Distribución GNU/Linux serán actualizados correctamente.</p><p>Pero en una organización, la primera dificultad importante a la que se va a enfrentar un administrador, va a ser la de la <strong>personalización</strong>.</p><h2 id="personalizacion-inicial-y-evolutiva" tabindex="-1"><a class="header-anchor" href="#personalizacion-inicial-y-evolutiva"><span>Personalización inicial y evolutiva</span></a></h2><p>Imagina que tienes que migrar 1000 equipos a GNU/Linux. Imagina también que tienes en tu red un servicio NTP y se requiere que todos tus escritorios estén sincronizados con este servicio. Vas a tener que personalizar el cliente NTP en todos tus escritorios. Una solución sería partir de una instalación desde el DVD de la Distribución que hayas elegido, editar el fichero de configuración del cliente NTP y configurar la IP del servidor donde se encuentra el servicio NTP. Después puedes crear una imagen del disco duro con Clonezilla y migrar uno a uno los 1000 equipos usando dicha imagen. Una personalización inicial usando este método es sencilla de realizar y puede ser muy útil. Pero sigamos imaginando. Un día, a mitad de migración, recibes una petición como esta:</p><blockquote><p>A partir del día 10, NTP va a dejar de dar servicio y en su lugar vamos a poner un nuevo servicio llamado &quot;QueHoraEs&quot; que es mucho mejor porque...</p></blockquote><p>En este momento piensas en los 400 equipos que tienes ya migrados y te echas las manos a la cabeza, pensando qué vas a hacer para actualizarlos.</p><p>Recuerda esto: <strong>La personalización inicial es muy sencilla de realizar pero la personalización puede darse en cualquier momento, y tienes que estar preparado para poder realizarla.</strong></p><p>Afortunadamente, existen unas herramientas denominadas <strong>Gestores de Sistemas</strong> (Systems Management Systems) que pueden sacarnos del apuro. Algunos de estos Gestores de Sistemas se centran en la adquisición del inventario hardware (como OCSInventory), otros sobre la adquisición del estado de los equipos (como Nagios), y otros permiten automatizar tareas mediante la ejecución de código en los equipos de manera centralizada (Zenworks for linux, Landscape, chef, puppet, cfengine, etc.).</p><h2 id="gestores-de-sistemas" tabindex="-1"><a class="header-anchor" href="#gestores-de-sistemas"><span>Gestores de sistemas</span></a></h2><p>Veamos un ejemplo de funcionamiento típico de un <strong>Gestor de Sistemas</strong>. Mediante un lenguaje propio de tipo declarativo se escribe un código que especifica a qué estado se quiere llevar a los equipos, no cómo llegar a ese estado, en nuestro caso sería algo parecido a esto:</p><ul><li><p>asegúrate que el paquete <code>ntp-client</code> está desinstalado</p></li><li><p>asegúrate que el paquete <code>quehoraes-client</code> está instalado</p></li><li><p>asegúrate que el fichero de configuración de <code>quehoraes-client</code> es el mismo que el que está en el servidor.</p></li></ul><p>Periódicamente, los clientes se conectarán al servidor para obtener este código que será ejecutado mediante el <strong>intérprete propio</strong> del Gestor de Sistemas instalado en el cliente.</p><p>Este sistema permite automatizar aquellas tareas que realizan a menudo los administradores de sistemas, y aunque algunos Gestores de Sistemas se las ingenian para llevar un control de versiones y de dependencias, mantienen una base de datos independiente de la de los <em>backends</em> de los gestores. ¿Tengo alguna manera de saber qué cambios (de aplicaciones y de personalizaciones) se han producido en el sistema? Realizan muy bien su tarea, es cierto, pero también es cierto que la integridad frente a los cambios queda en entredicho.</p><h2 id="empaquetar-la-personalizacion" tabindex="-1"><a class="header-anchor" href="#empaquetar-la-personalizacion"><span>Empaquetar la personalización</span></a></h2><p>En AZLinux usamos otro método: <strong>Empaquetamos siempre la personalización.</strong></p><p>Para el caso del cliente &quot;QueHoraEs&quot;, escribiríamos en nuestro lenguaje favorito (<code>bash</code>, <code>python</code>, <code>perl</code>, <code>ruby</code>...) un código similar a este:</p><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-txt"><span class="line"><span># Código a ejecutar después de la instalación:</span></span>
<span class="line"><span>En el fichero de configuración del cliente QueHoraes, modificar el valor de la entrada “server=” por la IP del servidor QueHoraEs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>y crearíamos un paquete con la siguiente metainformación:</p><ul><li>Dependencias: <code>quehoraes-client</code></li><li>Obsoletos: <code>ntp-client</code></li></ul><p>¡Listo! Con esto queda garantizada la integridad frente al cambio ya que hacemos uso del sistema de paquetería de nuestra Distribución.</p><p>Date cuenta que no es necesario ningún Gestor de Sistemas para instalar dicha personalización. Sólo necesitas el <strong>Gestor de Paquetes</strong>, y éste siempre lo tienes disponible.</p><h2 id="liberaciones-en-una-organizacion" tabindex="-1"><a class="header-anchor" href="#liberaciones-en-una-organizacion"><span>Liberaciones en una organización</span></a></h2><p>El segundo problema con el que vas a tener que lidiar es el de la <strong>liberación</strong>.</p><p>Por un lado, debes <strong>independizarte</strong> de los repositorios públicos de tu Distribución GNU/Linux, por el simple motivo que no puedes permitir que el control de los cambios que se instalarán en tus máquinas lo tenga tu Distribución GNU/Linux en vez de tu organización. ¿Imaginas que habría pasado en AZLinux cuando OpenSuSE sustituyó OpenOffice por LibreOffice? Cuando los usuarios hubieran encendido las máquinas a las 8:00 de la mañana, se iniciaría la actualización a LibreOffice automáticamente, pudiéndose producir muchas incidencias, ¿funcionaría todo? ¿No es mejor probar LibreOffice antes de liberarlo a los usuarios?</p><p>Tienes que poder decidir por ti mismo el software que deben tener tus usuarios y por tanto debes tener los gestores de paquetes configurados a tus propios repositorios de paquetes y gestionarlos de alguna manera.</p><p>Además, es necesario tener la posibilidad de poder <strong>planificar</strong> a quién y cuándo liberar los cambios. Imagina nuevamente el ejemplo de la sustitución de OpenOffice por LibreOffice, estaríamos hablando de una actualización de cerca de 500 MB por equipo que multiplicado por 600 equipos a la vez... es evidente que es mucho tráfico de red.</p><p>Además, otra ventaja de planificar la liberación es que permite distribuir poco a poco los cambios, de tal manera, que si hay errores afectará inicialmente a muy pocos equipos permitiendo actuar de manera más relajada para corregir cualquier incidencia.</p><h2 id="repositorio-migasfree" tabindex="-1"><a class="header-anchor" href="#repositorio-migasfree"><span>Repositorio migasfree</span></a></h2><p>Por todo esto, y como los repositorios estándar de las Distribuciones no tienen ningún mecanismo de planificación de la liberación, es por lo que decidimos desarrollar <strong>migasfree</strong>, extendiendo el concepto de repositorio de paquetes al concepto de <strong>repositorio de paquetes planificable</strong>.</p><p>Un repositorio de migasfree es simplemente un repositorio estándar más la capacidad de poder especificar cuándo y quién puede acceder a ese repositorio.</p><h2 id="funcionamiento-de-migasfree" tabindex="-1"><a class="header-anchor" href="#funcionamiento-de-migasfree"><span>Funcionamiento de migasfree</span></a></h2><p>Veamos el funcionamiento de migasfree:</p><ol><li><p><strong>Los cambios son empaquetados y subidos al servidor migasfree.</strong></p></li><li><p>Se crea un <strong>Repositorio Lógico</strong> con los paquetes subidos y se establece a quién (atributos de usuario+equipo), y en qué momento se deben aplicar dichos cambios. Esto no es más que un registro en la tabla de Repositorios de la base de datos de migasfree.</p></li><li><p>El servidor migasfree crea un <strong>Repositorio Físico</strong> (idéntico al de cualquier Distribución GNU/Linux) con dichos paquetes, utilizando las herramientas estándar de creación de repositorios (<code>createrepo</code> para paquetería RPM o <code>dpkg-scanpackages</code> para paquetería Debian).</p></li><li><p>Cuando un cliente se conecta al servidor le pasa sus atributos.</p></li><li><p>El servidor <strong>consulta los Registros Lógicos</strong> para determinar, en función de los atributos pasados, la lista de los <strong>Repositorios Físicos</strong> que tiene el cliente a su disposición y se los pasa al cliente.</p></li><li><p>El cliente <strong>configura, en el Gestor de Paquetes</strong>, los Repositorios Físicos.</p></li><li><p>El cliente da <strong>instrucciones al Gestor de Paquetes</strong> para que se produzca la instalación,<br> actualización y eliminación de los paquetes desde los Repositorios Físicos.</p></li></ol><h2 id="gcs-en-una-organizacion" tabindex="-1"><a class="header-anchor" href="#gcs-en-una-organizacion"><span>GCS en una organización</span></a></h2><p>Hemos hablado anteriormente del proceso de la <strong>GCS</strong> en los distintos proyectos de software libre y también del de las Distribuciones GNU/Linux. Pues bien, en una organización también debe realizarse el proceso de la GCS.</p><p>En AZLinux realizamos nuestra propia GCS y vemos cómo se repiten nuevamente las mismas actividades: petición de cambio, cambio y liberación.</p><p>Usamos dos tipos de peticiones de cambio:</p><ol><li><p><strong>Actualización de aplicaciones</strong>. Si recibimos una petición para actualizar, por ejemplo, Mozilla Firefox, descargamos desde los repositorios de la Distribución la versión deseada, la probamos en laboratorio, registrando cualquier información relevante en la petición de cambio. Finalmente, cuando todo está correcto, se liberan los paquetes a través de un repositorio migasfree, planificando su distribución.</p></li><li><p><strong>Personalización de aplicaciones</strong>. Se produce cuando llega, por ejemplo, una petición de cambio para añadir un motor de búsqueda de sinónimos a Mozilla Firefox. Introducimos entonces, en un paquete propio de AZLinux (<code>azl-firefox</code>), el código que instala dicho motor de búsqueda y liberamos el paquete también en un repositorio de migasfree planificando la distribución del cambio.</p></li></ol><p>Las herramientas que usamos en cada actividad son:</p><ul><li><strong>Petición</strong> de cambio: <strong>Redmine</strong>.</li><li><strong>Cambio</strong>: Únicamente un editor de textos, como <strong>Geany</strong>.</li><li><strong>Liberación</strong>: <strong>Migasfree</strong>.</li></ul><h2 id="beneficios-de-la-gcs" tabindex="-1"><a class="header-anchor" href="#beneficios-de-la-gcs"><span>Beneficios de la GCS</span></a></h2><p>Y llegados a este punto, puedes estar pensando: Entiendo que el objetivo de la GCS es <strong>garantizar la integridad</strong> frente a los cambios y su importancia, y como el sistema de paquetería me facilita enormemente alcanzar dicho objetivo pero, ¿qué beneficios concretos me aporta aplicar todo esto en mi empresa?</p><p>Los beneficios que obtendrás son los que proporciona la propia GCS y, por tanto, tu empresa:</p><ol><li>Reducirá el coste de los servicios de desarrollo y mantenimiento.</li><li>Optimizará el uso de los recursos.</li></ol><p>Y para ti, como administrador:</p><ol><li>Tendrás equipos más estables.</li><li>Vas a pasar de ser un administrador que se echa las manos a la cabeza ante cualquier cambio a ser un <strong>administrador favorecedor del cambio</strong>, ya que tienes las herramientas apropiadas para hacer el seguimiento y control de los cambios.</li><li>Y, en última instancia, vas a mejorar sustancialmente la resolución de incidencias.</li></ol><h2 id="contacto" tabindex="-1"><a class="header-anchor" href="#contacto"><span>Contacto</span></a></h2><p>Si estás interesado en hacer una GCS simple y eficaz, accede a la dirección del proyecto de <a href="https://migasfree.org" target="_blank" rel="noopener noreferrer">migasfree</a>.</p><p>Puedes también contactar con nosotros a través de Twitter.</p>`,100)])])}const c=a(n,[["render",r]]),p=JSON.parse('{"path":"/presentaciones/migasfree-gcs.html","title":"migasfree en la Gestión de la Configuración","lang":"es-ES","frontmatter":{"title":"migasfree en la Gestión de la Configuración","author":"jact, alberto","date":"2012-01-12T10:00:00.000Z","timeline":false,"description":"Analiza la importancia de gestionar los cambios de software para garantizar la integridad del sistema, lo que es esencial para que las organizaciones mantengan sistemas estables. Los beneficios de este enfoque son la reducción de los costes de desarrollo y mantenimiento, el aumento de la estabilidad del sistema y la mejora de las prácticas de gestión de cambios.","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"migasfree en la Gestión de la Configuración\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2012-01-12T10:00:00.000Z\\",\\"dateModified\\":\\"2025-07-04T05:37:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"jact, alberto\\"}]}"],["meta",{"property":"og:url","content":"http://migasfree.org/presentaciones/migasfree-gcs.html"}],["meta",{"property":"og:site_name","content":"Migasfree"}],["meta",{"property":"og:title","content":"migasfree en la Gestión de la Configuración"}],["meta",{"property":"og:description","content":"Analiza la importancia de gestionar los cambios de software para garantizar la integridad del sistema, lo que es esencial para que las organizaciones mantengan sistemas estables. Los beneficios de este enfoque son la reducción de los costes de desarrollo y mantenimiento, el aumento de la estabilidad del sistema y la mejora de las prácticas de gestión de cambios."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"es-ES"}],["meta",{"property":"og:updated_time","content":"2025-07-04T05:37:25.000Z"}],["meta",{"property":"article:author","content":"jact, alberto"}],["meta",{"property":"article:published_time","content":"2012-01-12T10:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-04T05:37:25.000Z"}]]},"git":{"createdTime":1751544245000,"updatedTime":1751607445000,"contributors":[{"name":"Jose Antonio Chavarría","username":"","email":"jachavar@gmail.com","commits":1},{"name":"jact","username":"jact","email":"jachavar@gmail.com","commits":1,"url":"https://github.com/jact"}]},"readingTime":{"minutes":9.85,"words":2956},"filePathRelative":"presentaciones/migasfree-gcs.md","excerpt":""}');export{c as comp,p as data};
